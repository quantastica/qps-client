// Generated by CoffeeScript 1.10.0
(function() {
  var DDP, async, attemptLogin, crypto, isEmail, login, loginWithAccount, loginWithEmail, loginWithToken, loginWithUsername, plaintextToDigest, read, tryOneAccount, tryOneEmail, tryOneToken, tryOneUser, userPrompt,
    slice = [].slice;

  read = require('read');

  DDP = require('ddp');

  async = require('async');

  crypto = require('crypto');

  login = function() {
    var cb, ddp, i, method, options, ref;
    ddp = arguments[0], options = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), cb = arguments[i++];
    if (typeof cb !== 'function') {
      throw new Error('Valid callback must be provided to ddp-login');
    }
    if (!(((ddp != null ? ddp.call : void 0) != null) && ((ddp != null ? ddp.connect : void 0) != null) && ((ddp != null ? ddp.close : void 0) != null))) {
      return cb(new Error('Invalid DDP parameter'));
    }
    options = (ref = options[0]) != null ? ref : {};
    if (options.env == null) {
      options.env = 'METEOR_TOKEN';
    }
    if (options.method == null) {
      options.method = 'account';
    }
    if (options.retry == null) {
      options.retry = 5;
    }
    if (options.plaintext == null) {
      options.plaintext = false;
    }
    if (options.account == null) {
      options.account = null;
    }
    if (options.pass == null) {
      options.pass = null;
    }
    switch (options.method) {
      case 'username':
        method = tryOneUser;
        break;
      case 'email':
        method = tryOneEmail;
        break;
      case 'account':
        method = tryOneAccount;
        break;
      case 'token':
        method = tryOneToken;
        break;
      default:
        return cb(new Error("Unsupported DDP login method '" + options.method + "'"));
    }
    if (process.env[options.env] != null) {
      return tryOneToken(ddp, options, function(err, res) {
        if (!(err || !res)) {
          return cb(null, res);
        } else {
          return async.retry(options.retry, async.apply(method, ddp, options), cb);
        }
      });
    } else {
      return async.retry(options.retry, async.apply(method, ddp, options), cb);
    }
  };

  plaintextToDigest = function(pass) {
    var hash;
    hash = crypto.createHash('sha256');
    hash.update(pass, 'utf8');
    return hash.digest('hex');
  };

  isEmail = function(addr) {
    var m, matchEmail;
    if (typeof addr !== 'string') {
      return false;
    }
    matchEmail = /^[^@]+@[^@]+\.[^@]+$/i;
    m = addr.match(matchEmail);
    return m !== null;
  };

  attemptLogin = function(ddp, user, pass, options, cb) {
    var digest;
    digest = plaintextToDigest(pass);
    return ddp.call('login', [
      {
        user: user,
        password: {
          digest: digest,
          algorithm: 'sha-256'
        }
      }
    ], function(err, res) {
      var details, e, error, srpDigest;
      if (!(err && err.error === 400)) {
        if (err) {
          console.error('Login failed:', err.message);
        }
        return cb(err, res);
      }
      if (err.reason === 'old password format') {
        console.error('Old Meteor SRP (pre-v0.8.2) account detected. Attempting to migrate...');
        try {
          details = JSON.parse(err.details);
        } catch (error) {
          e = error;
          return cb(err);
        }
        srpDigest = plaintextToDigest(details.identity + ":" + pass);
        return ddp.call('login', [
          {
            user: user,
            srp: srpDigest,
            password: {
              digest: digest,
              algorithm: 'sha-256'
            }
          }
        ], cb);
      } else if (options.plaintext) {
        return ddp.call('login', [
          {
            user: user,
            password: pass
          }
        ], function(err, res) {
          if (err) {
            console.error('Login failed: ', err.message);
          }
          return cb(err, res);
        });
      } else {
        return cb(err, res);
      }
    });
  };

  loginWithUsername = function() {
    var cb, ddp, i, options, password, username;
    ddp = arguments[0], username = arguments[1], password = arguments[2], options = 5 <= arguments.length ? slice.call(arguments, 3, i = arguments.length - 1) : (i = 3, []), cb = arguments[i++];
    return attemptLogin(ddp, {
      username: username
    }, password, options[0], cb);
  };

  loginWithEmail = function() {
    var cb, ddp, email, i, options, password;
    ddp = arguments[0], email = arguments[1], password = arguments[2], options = 5 <= arguments.length ? slice.call(arguments, 3, i = arguments.length - 1) : (i = 3, []), cb = arguments[i++];
    return attemptLogin(ddp, {
      email: email
    }, password, options[0], cb);
  };

  loginWithAccount = function() {
    var account, cb, ddp, i, options, password;
    ddp = arguments[0], account = arguments[1], password = arguments[2], options = 5 <= arguments.length ? slice.call(arguments, 3, i = arguments.length - 1) : (i = 3, []), cb = arguments[i++];
    if (isEmail(account)) {
      return loginWithEmail(ddp, account, password, options[0], function(err, tok) {
        if (!(err && err.error === 400)) {
          return cb(err, tok);
        }
        return loginWithUsername(ddp, account, password, options[0], cb);
      });
    } else {
      return loginWithUsername(ddp, account, password, options[0], cb);
    }
  };

  loginWithToken = function(ddp, token, cb) {
    return ddp.call('login', [
      {
        resume: token
      }
    ], cb);
  };

  tryOneToken = function(ddp, options, cb) {
    return loginWithToken(ddp, process.env[options.env], function(err, res) {
      return cb(err, res);
    });
  };

  userPrompt = function(prompt, options, cb) {
    var readPrompts;
    readPrompts = {};
    if (options.account == null) {
      readPrompts.account = async.apply(read, {
        prompt: prompt,
        output: process.stderr
      });
    }
    if (options.pass == null) {
      readPrompts.pass = async.apply(read, {
        prompt: 'Password: ',
        silent: true,
        output: process.stderr
      });
    }
    return async.series(readPrompts, function(err, res) {
      var ref, ref1, result;
      if (err) {
        cb(err);
      }
      result = {};
      result.account = ((ref = res.account) != null ? ref[0] : void 0) || options.account;
      result.pass = ((ref1 = res.pass) != null ? ref1[0] : void 0) || options.pass;
      return cb(null, result);
    });
  };

  tryOneEmail = function(ddp, options, cb) {
    return userPrompt("Email: ", options, function(err, res) {
      if (err) {
        return cb(err);
      }
      return loginWithEmail(ddp, res.account, res.pass, options, cb);
    });
  };

  tryOneUser = function(ddp, options, cb) {
    return userPrompt("Username: ", options, function(err, res) {
      if (err) {
        return cb(err);
      }
      return loginWithUsername(ddp, res.account, res.pass, options, cb);
    });
  };

  tryOneAccount = function(ddp, options, cb) {
    return userPrompt("Account: ", options, function(err, res) {
      if (err) {
        return cb(err);
      }
      return loginWithAccount(ddp, res.account, res.pass, options, cb);
    });
  };

  login._command_line = function() {
    var argv, ddp, yargs;
    yargs = require('yargs').usage('\nUsage: $0 [--host <hostname>] [--port <portnum>] [--env <envvar>] [--method <logintype>] [--retry <count>] [--ssl] [--plaintext]\n\nOutput: a valid authToken, if successful\n\nNote: If your Meteor server is older than v0.8.2, you will need to use the --plaintext option to authenticate.').example('', '\nexport METEOR_TOKEN=$($0 --host 127.0.0.1 --port 3000 --env METEOR_TOKEN --method email --retry 5)')["default"]('host', '127.0.0.1').describe('host', 'The domain name or IP address of the host to connect with')["default"]('port', 3000).describe('port', 'The server port number to connect with')["default"]('env', 'METEOR_TOKEN').describe('env', 'The environment variable to check for a valid token')["default"]('method', 'account').describe('method', 'The login method: currently "email", "username", "account" or "token"')["default"]('retry', 5).describe('retry', 'Number of times to retry login before giving up').describe('ssl', 'Use an SSL encrypted connection to connect with the host').boolean('ssl')["default"]('ssl', false).describe('plaintext', 'For Meteor servers older than v0.8.2, fallback to sending the password as plaintext')["default"]('plaintext', false).boolean('plaintext').boolean('h').alias('h', 'help').wrap(null).version((function() {
      return require('../package').version;
    }));
    argv = yargs.parse(process.argv);
    if (argv.h) {
      yargs.showHelp();
      process.exit(1);
    }
    ddp = new DDP({
      host: argv.host,
      port: argv.port,
      use_ssl: argv.ssl,
      use_ejson: true
    });
    return ddp.connect(function(err) {
      if (err) {
        throw err;
      }
      return login(ddp, {
        env: argv.env,
        method: argv.method,
        retry: argv.retry,
        plaintext: argv.plaintext
      }, function(err, res) {
        ddp.close();
        if (err) {
          console.error("Login attempt failed with error:");
          console.dir(err);
          process.exit(1);
          return;
        }
        console.log(res.token);
        process.exit(0);
      });
    });
  };

  login.loginWithToken = loginWithToken;

  login.loginWithUsername = loginWithUsername;

  login.loginWithEmail = loginWithEmail;

  login.loginWithAccount = loginWithAccount;

  if (typeof module !== "undefined" && module !== null) {
    module.exports = login;
  }

}).call(this);
